{#
First input argument consists of a dictionary with keys _common_ and _per_warp_.
Keys map to lists of tuples with (name, dtype, num_elements) of each subarray.
#}
{%- macro declare_smem_arrays(arrays, warp_loc_var, config) %}
    {%- set warps_per_block = divide(config.num_threads, config.warp_size) %}
    extern __shared__ char s[];
    {%- set ns = {"offset": 0, "total_warp_bytes": 0} %}
    {%- for name, dtype, num_elements in arrays["common"] %}
        {{dtype}}* {{name}} = ({{dtype}}*) (s + {{ ns["offset"] }});
        {%- do ns.update({"offset": ns["offset"] + num_elements * sizeof(dtype)}) %}
        {%- if ns["offset"] > config.smem %}
            {{ raise("Error, required shared memory exceeds allocation maximum!") }}
        {%- endif %}
    {%- endfor %}

    {%- for name, dtype, num_elements in arrays["per_warp"] %}
        {% do ns.update({"total_warp_bytes": ns["total_warp_bytes"] + num_elements * sizeof(dtype)}) %}
    {%- endfor %}

    {%- if ns["offset"] + ns["total_warp_bytes"] * warps_per_block > config.smem %}
        {{ raise("Error, required shared memory exceeds allocation maximum!") }}
    {%- endif %}

    char* per_warp_smem = s + {{ns["offset"]}} + {{ns["total_warp_bytes"]}} * {{ warp_loc_var }};

    {%- do ns.update({"offset": 0}) %}
    {%- for name, dtype, num_elements in arrays["per_warp"] %}
        {{dtype}}* {{name}} = ({{dtype}}*) (per_warp_smem + {{ ns["offset"] }});
        {% do ns.update({"offset": ns["offset"] + num_elements * sizeof(dtype)}) %}
    {%- endfor %}
{%- endmacro %}

{# smem contains a mul_ir stored in row-major order as mul * rep, where mul
   is at most 32. reg is at least a |rep|-sized register array on each thread.
       Assumes: each thread has the lane_id. #}
{%- macro transpose_load(mul, dim, smem, offset, reg) %}
    if(lane_id < {{mul}}) {
        {%- for i in range(dim) %}
            {{reg}}[{{i}}] = {{smem}}[{{offset}} + lane_id * {{dim}} + {{i}}];
        {%- endfor %}
    }
{%- endmacro %}

{%- macro transpose_store(mul, dim, smem, offset, reg, op, coeff) %}
    if(lane_id < {{mul}}) {
        {%- for i in range(dim) %}
            {{smem}}[{{offset}} + lane_id * {{dim}} + {{i}}] {{op}} {{reg}}[{{i}}] * {{coeff}};
        {%- endfor %}
    }
{%- endmacro %}

{%- macro declare_smem_variables(segment, smem_base) %}
    {%- for name in segment.smem %}
        {%- if name != "total" %}
            {%- set smem_rng = segment.smem[name] %}
            {{ smem_rng["dtype"] }}* = ({{smem_rng["dtype"]}}*) ({{smem_base}} + {{smem_rng["offset"]}}); 
        {%- endif %}
    {%- endfor %}
{%- endmacro %}

{%- macro load_ir_segments(map, glb_ptr, smem_ptr, loop_var) %}
    {%- for (src_rng, dst_rng) in map.copy_ranges %}
        {%- set range_len = src_rng.stop - src_rng.start %}
        ROW_OPERATION({{range_len}}, {{loop_var}}, {{smem_ptr}}[{{loop_var}} + dst_rng.start + lane_id] = {{glb_ptr}}[{{loop_var}} + src_rng.start + lane_id])
    {%- endfor %}
{%- endmacro %}

{%- macro store_ir_segments(map, src_ptr, dst_ptr, loop_var) %}
    {%- for (src_rng, dst_rng) in map.copy_ranges %}
        {%- set range_len = src_rng.stop - src_rng.start %}
        ROW_OPERATION({{range_len}}, {{loop_var}}, {{glb_ptr}}[{{loop_var}} + src_rng.start + lane_id] = {{smem_ptr}}[{{loop_var}} + dst_rng.start + lane_id])
    {%- endfor %}
{%- endmacro %}
